#include <iostream>
#include <ncurses/ncurses.h>

using namespace std;

// Helper function algorithem
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Definisikan pasangan warna
enum ColorPairs {
    PAIR_BORDER = 1,
    PAIR_WALL = 2,
    PAIR_PATH = 3,
    PAIR_START_END = 4,
    PAIR_PLAYER = 5,
    PAIR_MENU = 6,
    PAIR_INFO = 7,
    PAIR_WIN = 8
};

// Konstanta Ukuran Labirin
const int MAZE_ROWS = 25;
const int MAZE_COLS = 51;

// Struktur posisi
struct Position {
    int row;
    int col;
};

// =============================================================
//  MAZE VERY EASY (Ukuran 25x51)
// =============================================================
char mazeVeryEasy[MAZE_ROWS][MAZE_COLS] = {
"##################################################",
"##  S                                  ##       ##",
"## ######################### ######### ## ########",
"##                        ## ##   ##   ## ##    ##",
"######################### ## ##   ##   ## ##    ##",
"##                     ## ## ##   ##   ## ##    ##",
"## ###################### ## ##   ##   ## ##    ##",
"##   ##                   ## ##   ####### ##    ##",
"## #########################      ##      ##### ##",
"##                                              ##",
"## ###############################################",
"##   ##                                         ##",
"##   ## #### ############################## ######",
"##   ##   ##       ##                 ##    ##  ##",
"##   ##   ##       ##                 ##        ##",
"##   ############# ## #### ############# #########",
"##   ##            ##  ##  ##            ##     ##",
"##   ########      ######  ##         ######### ##",
"##         ##      ##  ##  ## #####   ##        ##",
"##      ## ##      ##  ##  ##    ##   ##        ##",
"########## ##      ## #### ##    ##   ##        ##",
"##         ##      ##      ##    ######## ##### ##",
"## ############### ##########    ##       ##    ##",
"##                         ##             ## F  ##",
"##################################################",
};

// =============================================================
//  MAZE EASY (Ukuran 25x51)
// =============================================================
char mazeEasy[MAZE_ROWS][MAZE_COLS] = {
"##################################################",
"##  ##             ##                           ##",
"##     ## ########### ################ ######## ##",
"######### ##          ##      ##       ##       ##",
"##     ## ####### ############## ######## ########",
"## ##  ##    ##       ##         ##       ##    ##",
"## ######### ## ############# ##### ##### ########",
"## ##           ##            ## ## ##    ##    ##",
"## ############ ############# ## ## ##    ##    ##",
"##    ##         ##              ## ##    ##    ##",
"##### ########## ################## ## #####    ##",
"##        ##  ## ##              ## ##          ##",
"## #####  ##  ## ######## ######### ##    ##    ##",
"##    ##  ##  ## ##    ## ##     ##### ## ########",
"##### ##  ##  ## ##    ## ##           ##       ##",
"##    ##  ##  ## ##    ## ############ ##       ##",
"## #####  ###### ##        ##   F   ## ##       ##",
"## ##     ##     ######### ######## ## ###########",
"## S         ######     ## ##    ## ##          ##",
"## ######### ##         ## ##### ## ## ## ########",
"## ##  ##    ## ######           ## ## ## ##    ##",
"## ##  ## ##### ##  ############### ## ## #### ###",
"##     ##    ##                        ##       ##",
"##     ##    ##                        ##       ##",
"##################################################",
};

// =============================================================
//  MAZE MEDIUM (Ukuran 25x51)
// =============================================================
char mazeMedium[MAZE_ROWS][MAZE_COLS] = {
"##################################################",
"##          ##                                  ##",
"##          ## ################################ ##",
"## ########### ##          ##  ##  ##        ## ##",
"##                         ##  ##  ######### ## ##",
"######################## ####  ##  ##        ## ##",
"##                    ##   ##  ##  ##        ## ##",
"##                    ##  F##  ##  ######### ## ##",
"##################### ####### #### ##        ## ##",
"##    ##           ##              ##           ##",
"##    ## ####      ##### ###################### ##",
"##    ##   ## ####    ##           ##           ##",
"########   ##   ##    ##           ######       ##",
"##         ##   ##    ##               ###### ####",
"##         ##   ##    ##               ##       ##",
"##### ############### ## ### ############  #######",
"##    ##           ## ##  ## ##        ##       ##",
"##    ########     ## ##  ## ##        ######## ##",
"##    ##    ##     ## ##  ## ## ####   ##       ##",
"##    ##    ##     ## ##  ## ##   ##   ##  ##   ##",
"##### ##### ##     ## ###### ##   ##   ##  ##   ##",
"##  S       ##     ##        ##   ######## ##   ##",
"##### ################ ########   ##       ##   ##",
"##                  ##                     ##   ##",
"##################################################",
};

// =============================================================
//  MAZE HARD (Ukuran 25x51)
// =============================================================
char mazeHard[MAZE_ROWS][MAZE_COLS] = {
    "#################################################",
    "#S                                   #         F#",
    "#  ###########################  ######  ######  #",
    "#          #                 #      ##          #",
    "#  ###  #  #  #  ##########  #####  ##  #  ###  #",
    "#    #  #     #  #  ####     #      #####    #  #",
    "######  #######  #     #  ####  #####     ####  #",
    "#             #  ####  #     #      #  ####     #",
    "#  ############  #     ####  #####  #     #  ####",
    "#   #     #   #  #  ####     #      ####  #     #",
    "#  ##  #  #   #  #     ####  #  #####     ####  #",
    "#      #      #              #      #  #  #     #",
    "###############  #################  #  ####  ####",
    "#             #          #          ####        #",
    "#  #  ######  #########  #  ######  #     ####  #",
    "####  #           #      #      #####  ####     #",
    "#     #  #######  #  #########  #      #     ####",
    "#  ####     #     #          #  #  #####  #     #",
    "#     ####  #  #  #  ######  #  #      #  ####  #",
    "####  #        #  #      ##     #####  #  #     #",
    "#  #  #  #######  #####  ########      #  #  ####",
    "#     #                  #         #####  #     #",
    "#  ################  #########################  #",
    "#                                               #",
    "#################################################"
};

// =============================================================
//  MAZE VERY HARD (Ukuran 25x51)
// =============================================================
char mazeVeryHard[MAZE_ROWS][MAZE_COLS] = {
    "#################################################",
    "#              S                    #      #    #",
    "#  ##################  #######  #####   #       #",
    "#          #                 #      #   ######  #",
    "#  ###  #  #  #  ##########  #####  #        #  #",
    "#    #  #     #  #  ####     #      #####    #  #",
    "######  #######  #     #  ####  #####  #F  ###  #",
    "#             #  ####  #     #      #  ####     #",
    "#  ############  #     ####  #####  #     #  ####",
    "#   #     #      #  ####     #      ####  #     #",
    "#  ##  #  #   ####  #  ####  #  #####     ####  #",
    "#      #      #              #      #  #        #",
    "###############  #################  #  #  #  ####",
    "#                #       #          ####  #     #",
    "#  #  ######  #########  ########   #     ####  #",
    "####  #       #   #      #      #####  ####  #  #",
    "#        #######  #  ######  #  #   #        ####",
    "#  ####     #     #          #  #  #####  #     #",
    "#     ####  #  ####  #########  #      #  ####  #",
    "####  #        #      #  #      #####  #  #     #",
    "#  #  #  #######  #####  #####  #      #  #  ####",
    "#     #           #      #         #####  #     #",
    "#  ################  #####  ##################  #",
    "#  #                                            #",
    "#################################################"
};

// =============================================================
//  SETUP NCURSES
// =============================================================
void setupNcurses() {
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0);

    if (has_colors()) {
        start_color();
        init_pair(PAIR_BORDER, COLOR_WHITE, COLOR_BLACK);
        init_pair(PAIR_WALL, COLOR_BLUE, COLOR_BLUE);
        init_pair(PAIR_PATH, COLOR_BLACK, COLOR_BLACK);
        init_pair(PAIR_START_END, COLOR_YELLOW, COLOR_BLACK);
        init_pair(PAIR_PLAYER, COLOR_RED, COLOR_BLACK);
        init_pair(PAIR_MENU, COLOR_GREEN, COLOR_BLACK);
        init_pair(PAIR_INFO, COLOR_CYAN, COLOR_BLACK);
        init_pair(PAIR_WIN, COLOR_BLACK, COLOR_GREEN);
    }
}

void cleanupNcurses() {
    endwin();
}

// =============================================================
//  FIND START
// =============================================================
Position findStart(char maze[MAZE_ROWS][MAZE_COLS]) {
    for (int i = 0; i < MAZE_ROWS; ++i)
        for (int j = 0; j < MAZE_COLS - 1; ++j)
            if (maze[i][j] == 'S')
                return {i, j};
    return {-1, -1};
}

// =============================================================
//  DRAW MAZE
// =============================================================
void drawMaze(char maze[MAZE_ROWS][MAZE_COLS], const Position& playerPos,
              const string& levelName, int moves, int score)
{
    clear();
    int startY = 1;

    attron(COLOR_PAIR(PAIR_BORDER) | A_BOLD);
    mvprintw(startY - 1, 0, "+");
    for (int j = 1; j < MAZE_COLS; ++j) {
        mvprintw(startY - 1, j, "-");
        mvprintw(MAZE_ROWS + startY, j, "-");
    }
    mvprintw(startY - 1, MAZE_COLS, "+");
    mvprintw(MAZE_ROWS + startY, MAZE_COLS, "+");
    for (int i = 0; i < MAZE_ROWS; ++i) {
        mvprintw(i + startY, 0, "|");
        mvprintw(i + startY, MAZE_COLS, "|");
    }
    attroff(COLOR_PAIR(PAIR_BORDER) | A_BOLD);

    for (int i = 0; i < MAZE_ROWS; ++i) {
        for (int j = 0; j < MAZE_COLS - 1; ++j) {
            char cell = maze[i][j];
            int pairId = PAIR_PATH;

            if (cell == '#') {
                pairId = PAIR_WALL;
            } else if (cell == 'S' || cell == 'F') {
                pairId = PAIR_START_END;
            }

            attron(COLOR_PAIR(pairId));
            if (cell == '#') {
                mvaddch(i + startY, j + 1, ' ');
            } else if (cell == 'S') {
                mvaddch(i + startY, j + 1, 'S');
            } else if (cell == 'F') {
                mvaddch(i + startY, j + 1, 'F');
            } else {
                mvaddch(i + startY, j + 1, ' ');
            }
            attroff(COLOR_PAIR(pairId));
        }
    }

    attron(COLOR_PAIR(PAIR_PLAYER) | A_BOLD);
    mvaddch(playerPos.row + startY, playerPos.col + 1, 'O');
    attroff(COLOR_PAIR(PAIR_PLAYER) | A_BOLD);

    attron(COLOR_PAIR(PAIR_INFO) | A_BOLD);
    mvprintw(MAZE_ROWS + startY + 2, 2, ">>> MAZE GAME | Level: %s <<<", levelName.c_str());
    mvprintw(MAZE_ROWS + startY + 2, MAZE_COLS - 25, "Langkah: %d | Skor: %d", moves, score);
    attroff(COLOR_PAIR(PAIR_INFO) | A_BOLD);

    attron(COLOR_PAIR(PAIR_MENU));
    mvprintw(MAZE_ROWS + startY + 3, 2, "Navigasi: Tombol Panah | S: Mulai, F: Selesai");
    mvprintw(MAZE_ROWS + startY + 4, 2, "Tekan 'M' untuk kembali ke Menu, 'Q' untuk Keluar.");
    attroff(COLOR_PAIR(PAIR_MENU));

    refresh();
}

// =============================================================
//  RUN GAME
// =============================================================
bool runGame(char maze[MAZE_ROWS][MAZE_COLS], const string& levelName) {
    Position playerPos = findStart(maze);
    if (playerPos.row == -1) return true;

    int ch, nextRow, nextCol;
    int moveCount = 0;

    int scoreInit = 1000;
    if (levelName == "Very Easy") scoreInit = 1000;
    else if (levelName == "Easy") scoreInit = 900;
    else if (levelName == "Medium") scoreInit = 700;
    else if (levelName == "Hard") scoreInit = 500;
    else if (levelName == "Very Hard") scoreInit = 300;

    int score = scoreInit;

    while (true) {
        drawMaze(maze, playerPos, levelName, moveCount, score);
        ch = getch();

        if (ch == 'q' || ch == 'Q') return false;
        if (ch == 'm' || ch == 'M') return true;

        nextRow = playerPos.row;
        nextCol = playerPos.col;
        bool moved = false;

        if (ch == KEY_UP)    { nextRow--; moved = true; }
        if (ch == KEY_DOWN)  { nextRow++; moved = true; }
        if (ch == KEY_LEFT)  { nextCol--; moved = true; }
        if (ch == KEY_RIGHT) { nextCol++; moved = true; }

        if (moved && nextRow >= 0 && nextCol >= 0 &&
            nextRow < MAZE_ROWS && nextCol < MAZE_COLS - 1)
        {
            char nextCell = maze[nextRow][nextCol];

            if (nextCell != '#') {
                playerPos = { nextRow, nextCol };
                moveCount++;
                score = max(0, score - 5);
            }

            if (nextCell == 'F') {
                int finalScore = score + (1000 / max(1, moveCount));
                if (finalScore < 0) finalScore = 0;

                drawMaze(maze, playerPos, levelName, moveCount, finalScore);

                // === WIN SCREEN ===
                clear();

                int boxW = 50;
                int boxH = 12;
                int startY = (LINES - boxH) / 2;
                int startX = (COLS - boxW) / 2;

                // Box border
                attron(COLOR_PAIR(PAIR_BORDER) | A_BOLD);
                for (int i = 0; i < boxH; i++) {
                    for (int j = 0; j < boxW; j++) {
                        if (i == 0 && j == 0) mvaddch(startY + i, startX + j, '+');
                        else if (i == 0 && j == boxW - 1) mvaddch(startY + i, startX + j, '+');
                        else if (i == boxH - 1 && j == 0) mvaddch(startY + i, startX + j, '+');
                        else if (i == boxH - 1 && j == boxW - 1) mvaddch(startY + i, startX + j, '+');
                        else if (i == 0 || i == boxH - 1) mvaddch(startY + i, startX + j, '-');
                        else if (j == 0 || j == boxW - 1) mvaddch(startY + i, startX + j, '|');
                    }
                }
                attroff(COLOR_PAIR(PAIR_BORDER) | A_BOLD);

                // Judul menang
                attron(COLOR_PAIR(PAIR_WIN) | A_BOLD);
                mvprintw(startY + 2, startX + 12, "*** ANDA MENANG! ***");
                attroff(COLOR_PAIR(PAIR_WIN) | A_BOLD);

                // Informasi score
                attron(COLOR_PAIR(PAIR_INFO));
                mvprintw(startY + 4, startX + 5, "Total Langkah : %d", moveCount);
                mvprintw(startY + 5, startX + 5, "Final Score   : %d", finalScore);
                attroff(COLOR_PAIR(PAIR_INFO));

                // Garis pemisah
                attron(COLOR_PAIR(PAIR_BORDER));
                mvprintw(startY + 6, startX + 2, "----------------------------------------------");
                attroff(COLOR_PAIR(PAIR_BORDER));

                // Menu pilihan
                attron(COLOR_PAIR(PAIR_MENU));
                mvprintw(startY + 8, startX + 5, "1. Main lagi level ini");
                mvprintw(startY + 9, startX + 5, "2. Kembali ke Menu Utama");
                mvprintw(startY + 10, startX + 5, "3. Keluar Game");
                attroff(COLOR_PAIR(PAIR_MENU));

                refresh();

                int pilih;
                while (true) {
                    pilih = getch();
                    if (pilih == '1') {
                        return runGame(maze, levelName);
                    }
                    else if (pilih == '2') {
                        return true;
                    }
                    else if (pilih == '3') {
                        return false;
                    }
                }
            }
        }
    }

    return true;
}

// =============================================================
//  MENU
// =============================================================
int showMenu() {
    int choice = 1, key;

    while (true) {
    	
    	//menu
    }
}

// =============================================================
//  MAIN PROGRAM
// =============================================================
int main() {
    setupNcurses();

    bool running = true;
    while (running) {
        int level = showMenu();
        bool cont = true;

        if (level == 1) cont = runGame(mazeVeryEasy, "Very Easy");
        else if (level == 2) cont = runGame(mazeEasy, "Easy");
        else if (level == 3) cont = runGame(mazeMedium, "Medium");
        else if (level == 4) cont = runGame(mazeHard, "Hard");
        else if (level == 5) cont = runGame(mazeVeryHard, "Very Hard");
        else running = false;

        if (!cont) running = false;
    }

    cleanupNcurses();
    return 0;
}
